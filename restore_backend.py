import os

files = {
    "backend/requirements.txt": """# FastAPI and server
fastapi==0.110.0
uvicorn[standard]==0.29.0
python-multipart==0.0.9

# Database
sqlalchemy==2.0.29
alembic==1.13.1

# Authentication
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-dotenv==1.0.1
pydantic[email]==2.6.4
pydantic-settings==2.2.1

# HTTP client (for Gemini API calls)
httpx==0.27.0

# Development
black==24.3.0
""",
    "backend/app/main.py": '"""\nGoal Achiever API - Main FastAPI Application\n"""\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.config import settings\nfrom app.database import engine, Base\nfrom app.routes import auth, goals, plans, chat\n\n# Auto-create tables (for SQLite / dev mode)\nBase.metadata.create_all(bind=engine)\n\napp = FastAPI(\n    title="Goal Achiever API",\n    description="AI-powered goal tracking and daily plan generation",\n    version="0.1.0",\n    docs_url="/docs",\n    redoc_url="/redoc"\n)\n\n# CORS middleware - allow both web frontend and mobile app\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],  # Allow all origins for mobile dev\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Include routers\napp.include_router(auth.router, prefix="/auth", tags=["Authentication"])\napp.include_router(goals.router, prefix="/goals", tags=["Goals"])\napp.include_router(plans.router, prefix="/plans", tags=["Plans"])\napp.include_router(chat.router, prefix="/chat", tags=["Chat"])\n\n\n@app.get("/", tags=["Health"])\nasync def root():\n    """Health check endpoint"""\n    return {\n        "status": "healthy",\n        "service": "Goal Achiever API",\n        "version": "0.1.0"\n    }\n\n\n@app.get("/health", tags=["Health"])\nasync def health_check():\n    """Detailed health check"""\n    return {\n        "status": "healthy",\n        "database": "connected",\n        "api": "operational"\n    }\n',
    "backend/app/config.py": '"""\nApplication configuration and settings\n"""\nfrom pydantic_settings import BaseSettings\nfrom typing import List\n\n\nclass Settings(BaseSettings):\n    """Application settings loaded from environment variables"""\n    \n    # Database\n    DATABASE_URL: str = "sqlite:///./goal_achiever.db"\n    \n    # JWT Authentication\n    JWT_SECRET: str = "dev-secret-key-for-testing-only-change-in-prod"\n    JWT_ALGORITHM: str = "HS256"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 10080  # 7 days\n    \n    # Google Gemini AI API\n    GEMINI_API_KEY: str = ""\n    \n    # Legacy Nebius (kept for backwards compat, now unused)\n    NEBIUS_API_KEY: str = ""\n    NEBIUS_API_URL: str = ""\n    NEBIUS_MODEL: str = ""\n    \n    # Application\n    DEBUG: bool = True\n    CORS_ORIGINS: List[str] = [\n        "http://localhost:3000",\n        "http://localhost:8081",\n        "http://localhost:19006",\n        "http://localhost:19000",\n    ]\n    \n    class Config:\n        env_file = ".env"\n        case_sensitive = True\n\n\nsettings = Settings()\n',
    "backend/app/auth.py": '"""\nJWT authentication utilities\n"""\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom sqlalchemy.orm import Session\nfrom app.config import settings\nfrom app.database import get_db\nfrom app.models import User\n\n# Password hashing\npwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")\n\n# HTTP Bearer token scheme\nsecurity = HTTPBearer()\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    """Verify a password against its hash"""\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    """Hash a password"""\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    """Create a JWT access token"""\n    to_encode = data.copy()\n    \n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({"exp": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)\n    return encoded_jwt\n\n\ndef decode_access_token(token: str) -> dict:\n    """Decode and verify a JWT token"""\n    try:\n        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])\n        return payload\n    except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Could not validate credentials",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n\n\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security),\n    db: Session = Depends(get_db)\n) -> User:\n    """\n    Get the current authenticated user from the JWT token.\n    This is a dependency that can be used in route handlers.\n    """\n    token = credentials.credentials\n    payload = decode_access_token(token)\n    \n    user_id: str = payload.get("sub")\n    if user_id is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Could not validate credentials",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="User not found",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    \n    return user\n',
    "backend/app/schemas.py": '"""\nPydantic schemas for API request/response validation\n"""\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime, date\nfrom typing import Optional, Any\n\n\n# ==================== Auth Schemas ====================\n\nclass UserRegisterRequest(BaseModel):\n    """Request schema for user registration"""\n    email: EmailStr\n    password: str = Field(..., min_length=8, description="Password must be at least 8 characters")\n\n\nclass UserLoginRequest(BaseModel):\n    """Request schema for user login"""\n    email: EmailStr\n    password: str\n\n\nclass UserResponse(BaseModel):\n    """Response schema for user data"""\n    id: str\n    email: str\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass TokenResponse(BaseModel):\n    """Response schema for JWT token"""\n    access_token: str\n    token_type: str = "bearer"\n    user: UserResponse\n\n\n# ==================== Goal Schemas ====================\n\nclass GoalCreateRequest(BaseModel):\n    """Request schema for creating a goal"""\n    title: str = Field(..., min_length=1, max_length=200)\n    total_days: int = Field(..., ge=1, le=365, description="Number of days (1-365)")\n    start_date: Optional[str] = Field(None, description="Start date (YYYY-MM-DD), defaults to today")\n    focuses: Optional[list[str]] = Field(["dsa", "system_design", "genai"], description="Focus areas")\n    use_ai: bool = Field(False, description="Use AI for plan generation")\n\n\nclass GoalResponse(BaseModel):\n    """Response schema for goal data"""\n    id: str\n    user_id: str\n    title: str\n    total_days: int\n    start_date: Any  # date or datetime\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\n# ==================== Day Plan Schemas ====================\n\nclass DSAContent(BaseModel):\n    """DSA problem content"""\n    problem: str\n    difficulty: str\n    solution: Optional[str] = None\n    explanation: Optional[str] = None\n\n\nclass SystemDesignContent(BaseModel):\n    """System design topic content"""\n    topic: str\n    notes: Optional[str] = None\n    tradeoffs: Optional[list[str]] = None\n\n\nclass GenAIContent(BaseModel):\n    """Generative AI question content"""\n    question: str\n    answer: Optional[str] = None\n    resources: Optional[list[str]] = None\n\n\nclass DayPlanResponse(BaseModel):\n    """Response schema for day plan"""\n    id: str\n    goal_id: str\n    day_number: int\n    date: Any  # date or datetime\n    dsa: Optional[dict] = None\n    system_design: Optional[dict] = None\n    genai: Optional[dict] = None\n    completed: bool\n    completed_at: Optional[datetime] = None\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass DayPlanUpdateRequest(BaseModel):\n    """Request schema for updating a day plan"""\n    completed: Optional[bool] = None\n\n\n# ==================== Note Schemas ====================\n\nclass NoteCreateRequest(BaseModel):\n    """Request schema for creating a note"""\n    content: str = Field(..., min_length=1)\n\n\nclass NoteResponse(BaseModel):\n    """Response schema for note data"""\n    id: str\n    day_plan_id: str\n    content: str\n    created_at: datetime\n    updated_at: Optional[datetime] = None\n    \n    class Config:\n        from_attributes = True\n\n\n# ==================== Chat Schemas ====================\n\nclass ChatRequest(BaseModel):\n    """Request schema for sending a chat message"""\n    message: str = Field(..., min_length=1, max_length=2000)\n    session_id: Optional[str] = None\n    context_topic: Optional[str] = None  # e.g. "DSA: Two Sum"\n\nclass ChatResponse(BaseModel):\n    """Response schema for a chat reply"""\n    reply: str\n    session_id: str\n\nclass ChatMessageResponse(BaseModel):\n    """Response schema for a stored chat message"""\n    id: str\n    role: str\n    content: str\n    context_topic: Optional[str] = None\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nclass ChatHistoryResponse(BaseModel):\n    """Response schema for chat history"""\n    session_id: str\n    messages: list[ChatMessageResponse]\n',
    "backend/app/models.py": '"""\nSQLAlchemy database models\nSupports both PostgreSQL (UUID, JSONB) and SQLite (String, JSON) backends.\n"""\nimport uuid\nimport json\nfrom datetime import datetime\nfrom sqlalchemy import (\n    Column, String, Integer, Boolean, DateTime, ForeignKey, Text, Date, JSON\n)\nfrom sqlalchemy.orm import relationship\nfrom app.database import Base\nfrom app.config import settings\n\n# Use simple String UUIDs for SQLite compatibility\nIS_SQLITE = settings.DATABASE_URL.startswith("sqlite")\n\n\ndef generate_uuid():\n    return str(uuid.uuid4())\n\n\nclass User(Base):\n    """User model for authentication"""\n    __tablename__ = "users"\n    \n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    email = Column(String, unique=True, nullable=False, index=True)\n    password_hash = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    \n    # Relationships\n    goals = relationship("Goal", back_populates="user", cascade="all, delete-orphan")\n    chat_messages = relationship("ChatMessage", back_populates="user", cascade="all, delete-orphan")\n    \n    def __repr__(self):\n        return f"<User(email=\'{self.email}\')>"\n\n\nclass Goal(Base):\n    """Goal model representing a user\'s learning goal"""\n    __tablename__ = "goals"\n    \n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    user_id = Column(String(36), ForeignKey("users.id"), nullable=False)\n    title = Column(String, nullable=False)\n    total_days = Column(Integer, nullable=False)\n    start_date = Column(Date, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    \n    # Relationships\n    user = relationship("User", back_populates="goals")\n    day_plans = relationship("DayPlan", back_populates="goal", cascade="all, delete-orphan")\n    \n    def __repr__(self):\n        return f"<Goal(title=\'{self.title}\', days={self.total_days})>"\n\n\nclass DayPlan(Base):\n    """Daily plan with DSA, System Design, and GenAI content"""\n    __tablename__ = "day_plans"\n    \n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    goal_id = Column(String(36), ForeignKey("goals.id"), nullable=False)\n    day_number = Column(Integer, nullable=False)\n    date = Column(Date, nullable=False, index=True)\n    \n    # JSON content for each section\n    dsa = Column(JSON, nullable=True)\n    system_design = Column(JSON, nullable=True)\n    genai = Column(JSON, nullable=True)\n    \n    completed = Column(Boolean, default=False, nullable=False)\n    completed_at = Column(DateTime, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    \n    # Relationships\n    goal = relationship("Goal", back_populates="day_plans")\n    notes = relationship("Note", back_populates="day_plan", cascade="all, delete-orphan")\n    \n    def __repr__(self):\n        return f"<DayPlan(date=\'{self.date}\', day={self.day_number})>"\n\n\nclass Note(Base):\n    """User notes for a specific day"""\n    __tablename__ = "notes"\n    \n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    day_plan_id = Column(String(36), ForeignKey("day_plans.id"), nullable=False)\n    content = Column(Text, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    day_plan = relationship("DayPlan", back_populates="notes")\n    \n    def __repr__(self):\n        return f"<Note(id={self.id})>"\n\n\nclass ChatMessage(Base):\n    """Chat messages for interactive LLM practice"""\n    __tablename__ = "chat_messages"\n    \n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    user_id = Column(String(36), ForeignKey("users.id"), nullable=False)\n    session_id = Column(String(36), nullable=False, index=True)\n    role = Column(String(20), nullable=False)  # "user" or "assistant"\n    content = Column(Text, nullable=False)\n    context_topic = Column(String(200), nullable=True)  # e.g. "DSA: Two Sum"\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    \n    # Relationships\n    user = relationship("User", back_populates="chat_messages")\n    \n    def __repr__(self):\n        return f"<ChatMessage(role=\'{self.role}\', session=\'{self.session_id}\')>"\n',
    "backend/app/routes/auth.py": '"""\nAuthentication routes\n"""\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.database import get_db\nfrom app.models import User\nfrom app.schemas import UserRegisterRequest, UserLoginRequest, TokenResponse, UserResponse\nfrom app.auth import get_password_hash, verify_password, create_access_token\n\nrouter = APIRouter()\n\n\n@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)\nasync def register(user_data: UserRegisterRequest, db: Session = Depends(get_db)):\n    """\n    Register a new user account\n    """\n    # Check if user already exists\n    existing_user = db.query(User).filter(User.email == user_data.email).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail="Email already registered"\n        )\n    \n    # Create new user\n    hashed_password = get_password_hash(user_data.password)\n    new_user = User(\n        email=user_data.email,\n        password_hash=hashed_password\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    # Create access token\n    access_token = create_access_token(data={"sub": str(new_user.id)})\n    \n    return TokenResponse(\n        access_token=access_token,\n        user=UserResponse.from_orm(new_user)\n    )\n\n\n@router.post("/login", response_model=TokenResponse)\nasync def login(user_data: UserLoginRequest, db: Session = Depends(get_db)):\n    """\n    Login with email and password\n    """\n    # Find user by email\n    user = db.query(User).filter(User.email == user_data.email).first()\n    \n    if not user or not verify_password(user_data.password, user.password_hash):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Incorrect email or password",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    \n    # Create access token\n    access_token = create_access_token(data={"sub": str(user.id)})\n    \n    return TokenResponse(\n        access_token=access_token,\n        user=UserResponse.from_orm(user)\n    )\n',
    "backend/app/routes/chat.py": '"""\nChat routes - Interactive LLM-based practice conversations\n"""\nimport uuid\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.database import get_db\nfrom app.models import User, ChatMessage\nfrom app.schemas import ChatRequest, ChatResponse, ChatHistoryResponse, ChatMessageResponse\nfrom app.auth import get_current_user\nfrom app.services.ai_generator import AIPlanGenerator\n\nrouter = APIRouter()\n\n# Shared AI instance\n_ai = AIPlanGenerator()\n\n\n@router.post("", response_model=ChatResponse)\nasync def send_chat_message(\n    chat_data: ChatRequest,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """\n    Send a message to the AI tutor and get an interactive response.\n    Supports context-aware conversations about DSA, System Design, and GenAI.\n    """\n    session_id = chat_data.session_id or str(uuid.uuid4())\n\n    # Load recent conversation history for context (last 10 messages)\n    history = db.query(ChatMessage).filter(\n        ChatMessage.user_id == current_user.id,\n        ChatMessage.session_id == session_id\n    ).order_by(ChatMessage.created_at.desc()).limit(10).all()\n\n    history.reverse()  # chronological order\n\n    # Build conversation context\n    conversation_parts = []\n    for msg in history:\n        conversation_parts.append(f"{\'User\' if msg.role == \'user\' else \'Assistant\'}: {msg.content}")\n    conversation_parts.append(f"User: {chat_data.message}")\n    conversation_text = "\\n".join(conversation_parts)\n\n    # Build prompt\n    context_hint = ""\n    if chat_data.context_topic:\n        context_hint = f"\\nThe user is currently studying: {chat_data.context_topic}. Tailor your response to this topic."\n\n    prompt = f"""You are an expert AI tutor specializing in technical interview preparation covering Data Structures & Algorithms (DSA), System Design, and Generative AI.\n\nYour role:\n- Explain concepts clearly with examples\n- When asked about DSA, provide Python code solutions with step-by-step explanations\n- When asked about System Design, discuss architecture, tradeoffs, and scalability\n- When asked about GenAI, explain LLM concepts, transformers, RAG, fine-tuning, etc.\n- Give constructive feedback on the user\'s answers\n- Ask follow-up questions to deepen understanding\n- Keep responses concise but thorough\n- Use code blocks for any code snippets{context_hint}\n\nConversation so far:\n{conversation_text}\n\nProvide a helpful, encouraging response as the AI tutor:"""\n\n    try:\n        reply = await _ai._call_gemini_api(prompt)\n    except Exception as e:\n        print(f"Chat AI failed: {e}")\n        reply = "I\'m having trouble connecting to the AI service right now. Please try again in a moment."\n\n    # Save user message\n    user_msg = ChatMessage(\n        user_id=current_user.id,\n        session_id=session_id,\n        role="user",\n        content=chat_data.message,\n        context_topic=chat_data.context_topic\n    )\n    db.add(user_msg)\n\n    # Save assistant reply\n    assistant_msg = ChatMessage(\n        user_id=current_user.id,\n        session_id=session_id,\n        role="assistant",\n        content=reply,\n        context_topic=chat_data.context_topic\n    )\n    db.add(assistant_msg)\n    db.commit()\n\n    return ChatResponse(reply=reply, session_id=session_id)\n\n\n@router.get("/history/{session_id}", response_model=ChatHistoryResponse)\nasync def get_chat_history(\n    session_id: str,\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """Get chat history for a session"""\n    messages = db.query(ChatMessage).filter(\n        ChatMessage.user_id == current_user.id,\n        ChatMessage.session_id == session_id\n    ).order_by(ChatMessage.created_at.asc()).all()\n\n    return ChatHistoryResponse(\n        session_id=session_id,\n        messages=[ChatMessageResponse.model_validate(m) for m in messages]\n    )\n\n\n@router.get("/sessions", response_model=list[dict])\nasync def list_chat_sessions(\n    current_user: User = Depends(get_current_user),\n    db: Session = Depends(get_db)\n):\n    """List all chat sessions for the current user"""\n    from sqlalchemy import func, distinct\n\n    sessions = db.query(\n        ChatMessage.session_id,\n        ChatMessage.context_topic,\n        func.min(ChatMessage.created_at).label("started_at"),\n        func.count(ChatMessage.id).label("message_count")\n    ).filter(\n        ChatMessage.user_id == current_user.id\n    ).group_by(\n        ChatMessage.session_id, ChatMessage.context_topic\n    ).order_by(\n        func.max(ChatMessage.created_at).desc()\n    ).limit(20).all()\n\n    return [\n        {\n            "session_id": s.session_id,\n            "context_topic": s.context_topic,\n            "started_at": s.started_at.isoformat() if s.started_at else None,\n            "message_count": s.message_count\n        }\n        for s in sessions\n    ]\n'
}

for path, content in files.items():
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)

print("Restored known backend files!")
